"""Regenerate the top-level requirements.txt from app-specific requirement files."""

from __future__ import annotations

from pathlib import Path
from typing import Iterable

from packaging.requirements import Requirement
from packaging.specifiers import SpecifierSet

REPO_ROOT = Path(__file__).resolve().parents[1]
OUTPUT_FILE = REPO_ROOT / "requirements.txt"
SOURCE_REQUIREMENTS: list[Path] = [
    REPO_ROOT / "src" / "function_app" / "requirements.txt",
    REPO_ROOT / "src" / "webapp" / "requirements.txt",
]
EXTRA_REQUIREMENTS: list[str] = [
    "black",
    "packaging",
]


def _iter_requirement_lines(paths: Iterable[Path]) -> Iterable[str]:
    for path in paths:
        for raw_line in path.read_text().splitlines():
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue
            yield line


def _combine_specifiers(existing: SpecifierSet, incoming: SpecifierSet) -> SpecifierSet:
    if not str(existing):
        return incoming
    if not str(incoming):
        return existing
    return SpecifierSet(str(existing)) & SpecifierSet(str(incoming))


def generate_requirements() -> list[str]:
    """Return consolidated, sorted requirement strings."""
    requirements: dict[str, Requirement] = {}

    for line in _iter_requirement_lines(SOURCE_REQUIREMENTS):
        requirement = Requirement(line)
        key = requirement.name.lower()
        stored = requirements.get(key)

        if stored is None:
            requirements[key] = requirement
            continue

        if stored.extras != requirement.extras:
            extras = ", ".join(sorted(stored.extras ^ requirement.extras))
            raise ValueError(f"Conflicting extras for {requirement.name}: {extras}")

        combined_specifier = _combine_specifiers(
            stored.specifier, requirement.specifier
        )
        if stored.marker != requirement.marker:
            raise ValueError(f"Conflicting environment markers for {requirement.name}")

        extras_str = ""
        if stored.extras:
            extras_str = f"[{','.join(sorted(stored.extras))}]"

        merged = Requirement(f"{stored.name}{extras_str}{combined_specifier}")
        if stored.marker:
            merged.marker = stored.marker
        requirements[key] = merged

    for extra_requirement in EXTRA_REQUIREMENTS:
        requirement = Requirement(extra_requirement)
        key = requirement.name.lower()
        requirements[key] = requirement

    consolidated = []
    for key in sorted(requirements):
        requirement = requirements[key]
        requirement_str = requirement.name
        if requirement.extras:
            extras = ",".join(sorted(requirement.extras))
            requirement_str = f"{requirement_str}[{extras}]"

        specifier_str = str(requirement.specifier)
        if specifier_str:
            requirement_str = f"{requirement_str}{specifier_str}"

        if requirement.marker:
            requirement_str = f"{requirement_str}; {requirement.marker}"

        consolidated.append(requirement_str)

    return consolidated


def main() -> None:
    consolidated = generate_requirements()
    header = [
        "# Auto-generated by scripts/generate_requirements.py",
        "# Consolidated runtime requirements for local development tooling",
        "",
    ]
    OUTPUT_FILE.write_text("\n".join([*header, *consolidated]) + "\n")


if __name__ == "__main__":
    main()
